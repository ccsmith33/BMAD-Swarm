import { join } from 'node:path';
import { writeGeneratedJsFile, isFileManuallyModified, ensureDir } from '../utils/fs-helpers.js';

/**
 * Write a generated hook file with modification protection.
 * Skips writing if the file was manually modified (unless force is set).
 *
 * @param {string} filePath
 * @param {string} content
 * @param {object} [options]
 * @param {boolean} [options.force]
 * @returns {{ path: string, skipped: boolean }}
 */
function writeGeneratedHook(filePath, content, options = {}) {
  if (!options.force && isFileManuallyModified(filePath)) {
    return { path: filePath, skipped: true };
  }
  writeGeneratedJsFile(filePath, content);
  return { path: filePath, skipped: false };
}

/**
 * Generate Claude Code hooks for quality gate enforcement.
 * Creates Node.js scripts in .claude/hooks/ that run on specific events.
 *
 * @param {object} config - Parsed swarm.yaml config
 * @param {object} projectPaths - Project paths from getProjectPaths()
 * @param {object} [options] - Options
 * @param {boolean} [options.force] - Overwrite even if manually modified
 * @returns {{ generated: string[], skipped: string[] }} Lists of generated and skipped hook file paths
 */
export function generateHooks(config, projectPaths, options = {}) {
  ensureDir(projectPaths.hooksDir);
  const generated = [];
  const skipped = [];

  const hooks = [
    { name: 'TaskCompleted.cjs', generator: generateTaskCompletedHook },
    { name: 'TeammateIdle.cjs', generator: generateTeammateIdleHook },
    { name: 'orchestrator-post-tool.cjs', generator: generateOrchestratorPostToolHook },
    { name: 'orchestrator-stop.cjs', generator: generateOrchestratorStopHook },
    { name: 'identity-reinject.cjs', generator: generateIdentityReinjectHook },
    { name: 'task-tool-warning.cjs', generator: generateTaskToolWarningHook },
  ];

  for (const { name, generator } of hooks) {
    const filePath = join(projectPaths.hooksDir, name);
    const result = writeGeneratedHook(filePath, generator(config), options);
    if (result.skipped) {
      skipped.push(filePath);
    } else {
      generated.push(filePath);
    }
  }

  return { generated, skipped };
}

/**
 * Return the hooks configuration object for settings.json.
 * This is the SINGLE SOURCE OF TRUTH for all hook definitions.
 *
 * @returns {object} Hooks configuration for settings.json
 */
export function getHooksConfig() {
  return {
    PostToolUse: [
      {
        matcher: 'Edit|Write|Bash',
        hooks: [{ type: 'command', command: 'node .claude/hooks/orchestrator-post-tool.cjs' }],
      },
      {
        matcher: 'Task',
        hooks: [{ type: 'command', command: 'node .claude/hooks/task-tool-warning.cjs' }],
      },
    ],
    Stop: [
      {
        hooks: [{ type: 'command', command: 'node .claude/hooks/orchestrator-stop.cjs' }],
      },
    ],
    SessionStart: [
      {
        matcher: 'compact',
        hooks: [{ type: 'command', command: 'node .claude/hooks/identity-reinject.cjs' }],
      },
      {
        hooks: [{ type: 'command', command: 'node .claude/hooks/identity-reinject.cjs' }],
      },
    ],
  };
}

function generateTaskCompletedHook(config) {
  const enforce = config.hooks?.enforce || false;

  return `#!/usr/bin/env node
// BMAD Swarm - TaskCompleted Hook
// Generated by bmad-swarm - do not edit manually

const { execSync } = require('child_process');

const taskId = process.env.TASK_ID || '';
const taskSubject = process.env.TASK_SUBJECT || '';
const taskOwner = process.env.TASK_OWNER || '';

console.log(\`[BMAD Swarm] Task completed: \${taskSubject} (by \${taskOwner})\`);

const isImplementation = taskSubject.includes('implement') || taskSubject.includes('develop') || taskSubject.includes('dev-');

if (isImplementation) {
  try {
    execSync('npm test', { stdio: 'pipe', timeout: 60000 });
    console.log('[BMAD Swarm] \\u2713 Tests passed');
  } catch (err) {
    console.log('[BMAD Swarm] \\u2717 Tests failed');
    if (err.stdout) console.log(err.stdout.toString().slice(-500));
    ${enforce ? "process.exit(1);" : "console.log('[BMAD Swarm] Advisory: Fix failing tests before merging');"}
  }
}

process.exit(0);
`;
}

function generateTeammateIdleHook(config) {
  return `#!/usr/bin/env node
// BMAD Swarm - TeammateIdle Hook
// Generated by bmad-swarm - do not edit manually

const teammateName = process.env.TEAMMATE_NAME || '';
const teammateId = process.env.TEAMMATE_ID || '';

console.log(\`[BMAD Swarm] Teammate idle: \${teammateName}\`);

if (teammateName.includes('orchestrator')) {
  console.log('[BMAD Swarm] Warning: Orchestrator is idle - check if tasks are pending');
}

process.exit(0);
`;
}

function generateOrchestratorPostToolHook(config) {
  const codeDir = config.output?.code_dir || './src';

  return `#!/usr/bin/env node
// BMAD Swarm - PostToolUse Enforcement Hook
// Generated by bmad-swarm - do not edit manually
//
// Fires after Edit, Write, or Bash tool calls.
// Checks if the tool modified files in the protected code directory.
// If so, injects a warning into Claude's context via additionalContext.

const fs = require('fs');
const path = require('path');

const CODE_DIR = ${JSON.stringify(codeDir)};

let input = '';
process.stdin.setEncoding('utf8');
process.stdin.on('data', (chunk) => { input += chunk; });
process.stdin.on('end', () => {
  let event;
  try {
    event = JSON.parse(input);
  } catch {
    process.exit(0);
  }

  const toolName = event.tool_name || '';
  const toolInput = event.tool_input || {};
  const cwd = event.cwd || process.cwd();

  const resolvedCodeDir = path.resolve(cwd, CODE_DIR);
  let targetPath = null;

  if (toolName === 'Edit' || toolName === 'Write') {
    targetPath = toolInput.file_path || '';
  } else if (toolName === 'Bash') {
    const cmd = toolInput.command || '';
    // Heuristic: check if the command references the code directory
    if (cmd.includes(CODE_DIR) || cmd.includes(resolvedCodeDir)) {
      targetPath = resolvedCodeDir;
    }
  }

  if (!targetPath) {
    process.exit(0);
  }

  const resolvedTarget = path.resolve(cwd, targetPath);
  if (resolvedTarget.startsWith(resolvedCodeDir)) {
    // Write a marker file so the Stop hook can detect violations
    const markerPath = path.join(cwd, '.claude', 'hooks', '.code-modified-marker');
    try {
      fs.mkdirSync(path.dirname(markerPath), { recursive: true });
      fs.writeFileSync(markerPath, JSON.stringify({
        timestamp: Date.now(),
        tool: toolName,
        file: resolvedTarget,
      }));
    } catch {
      // Best effort - marker write failure should not block
    }

    const output = JSON.stringify({
      additionalContext: 'WARNING: You just modified source code in ' + CODE_DIR + ' directly. As the orchestrator, you must delegate all implementation to developer agents. Revert this change and spawn a developer agent to handle it.',
    });
    process.stdout.write(output);
  }

  process.exit(0);
});
`;
}

function generateOrchestratorStopHook(config) {
  const codeDir = config.output?.code_dir || './src';

  return `#!/usr/bin/env node
// BMAD Swarm - Stop Hook for Delegation Verification
// Generated by bmad-swarm - do not edit manually
//
// Fires when Claude is about to stop/respond.
// Checks if the orchestrator modified code files directly during this turn.
// If violations are detected, blocks the turn so the orchestrator must revert.

const fs = require('fs');
const path = require('path');

const CODE_DIR = ${JSON.stringify(codeDir)};

let input = '';
process.stdin.setEncoding('utf8');
process.stdin.on('data', (chunk) => { input += chunk; });
process.stdin.on('end', () => {
  const cwd = process.cwd();
  const markerPath = path.join(cwd, '.claude', 'hooks', '.code-modified-marker');

  let marker = null;
  try {
    const raw = fs.readFileSync(markerPath, 'utf8');
    marker = JSON.parse(raw);
  } catch {
    // No marker file = no violations
    process.exit(0);
  }

  // Check if the marker is recent (within the last 10 minutes)
  const age = Date.now() - (marker.timestamp || 0);
  if (age > 10 * 60 * 1000) {
    // Stale marker, clean up and pass
    try { fs.unlinkSync(markerPath); } catch {}
    process.exit(0);
  }

  // Violation detected - clean up marker and block
  try { fs.unlinkSync(markerPath); } catch {}

  const output = JSON.stringify({
    decision: 'block',
    reason: 'You implemented code in ' + CODE_DIR + ' directly instead of delegating to a developer agent. Revert your changes and delegate the implementation work to a developer agent.',
  });
  process.stdout.write(output);
  process.exit(0);
});
`;
}

function generateIdentityReinjectHook(config) {
  const projectName = config.project?.name || 'BMAD Swarm';

  return `#!/usr/bin/env node
// BMAD Swarm - SessionStart Identity Reinject Hook
// Generated by bmad-swarm - do not edit manually
//
// Fires on context compaction events and on every session start
// to re-inject orchestrator identity.
// Ensures the orchestrator remembers its role after context is compressed.

const output = JSON.stringify({
  additionalContext: 'IDENTITY REMINDER: You are the orchestrator of ' + ${JSON.stringify(projectName)} + '. Use TeamCreate to spawn teammates. Do NOT use Task tool with subagent_type=Explore for delegated work. Follow the entry point table in .claude/rules/orchestrator-methodology.md.',
});
process.stdout.write(output);
process.exit(0);
`;
}

function generateTaskToolWarningHook(config) {
  return `#!/usr/bin/env node
// BMAD Swarm - PostToolUse Task Tool Warning Hook
// Generated by bmad-swarm - do not edit manually
//
// Fires after Task tool calls.
// Warns the orchestrator to use TeamCreate instead of standalone Task subagents.

const output = JSON.stringify({
  additionalContext: 'WARNING: You used the Task tool directly. As the orchestrator, you should use TeamCreate to spawn BMAD teammates instead of standalone Task subagents. Only use Task for trivial, non-delegatable lookups.',
});
process.stdout.write(output);
process.exit(0);
`;
}
