import { existsSync, readdirSync } from 'node:fs';
import { join } from 'node:path';
import { writeFileSafe } from './fs-helpers.js';
import { loadYaml } from './config.js';

/**
 * Generate a run report summarizing a swarm session.
 * Written to artifacts/reviews/run-report-<date>.md
 *
 * @param {object} config - Parsed swarm.yaml config
 * @param {object} projectPaths - Project paths from getProjectPaths()
 * @param {object} [options] - Optional report data
 * @param {string[]} [options.agentsTasks] - Array of "agent: task" strings
 * @param {string[]} [options.phaseTransitions] - Array of "phase -> phase (time)" strings
 * @param {string[]} [options.qualityIssues] - Array of quality issue descriptions
 * @param {string[]} [options.decisions] - Array of decision descriptions
 * @returns {string} Path to the generated report
 */
export function generateRunReport(config, projectPaths, options = {}) {
  const date = new Date().toISOString().split('T')[0];
  const timestamp = new Date().toISOString();
  const reportDir = join(projectPaths.artifactsDir, 'reviews');
  const reportPath = join(reportDir, `run-report-${date}.md`);

  const artifacts = collectArtifacts(projectPaths);
  const phaseInfo = loadPhaseInfo(projectPaths);

  const sections = [];

  // Header
  sections.push(`# Run Report - ${date}`);
  sections.push('');
  sections.push(`**Project**: ${config.project.name}`);
  sections.push(`**Generated**: ${timestamp}`);
  sections.push(`**Autonomy**: ${config.methodology.autonomy}`);
  sections.push('');

  // Phase Status
  sections.push('## Phase Status');
  sections.push('');
  if (phaseInfo) {
    sections.push(`- **Current Phase**: ${phaseInfo.phase || 'unknown'}`);
    sections.push(`- **Status**: ${phaseInfo.status || 'unknown'}`);
    if (phaseInfo.phase_history && phaseInfo.phase_history.length > 0) {
      sections.push('');
      sections.push('### Phase History');
      sections.push('');
      for (const entry of phaseInfo.phase_history) {
        sections.push(`- ${entry.from} â†’ ${entry.to} (${entry.timestamp || 'no timestamp'})`);
      }
    }
  } else {
    sections.push('No phase data found (project.yaml missing).');
  }
  sections.push('');

  // Phase Transitions (from options)
  if (options.phaseTransitions && options.phaseTransitions.length > 0) {
    sections.push('### Session Transitions');
    sections.push('');
    for (const t of options.phaseTransitions) {
      sections.push(`- ${t}`);
    }
    sections.push('');
  }

  // Agents & Tasks
  sections.push('## Agents & Tasks');
  sections.push('');
  if (options.agentsTasks && options.agentsTasks.length > 0) {
    for (const at of options.agentsTasks) {
      sections.push(`- ${at}`);
    }
  } else {
    sections.push('No agent task data recorded for this session.');
  }
  sections.push('');

  // Artifacts Produced
  sections.push('## Artifacts Produced');
  sections.push('');
  if (artifacts.length > 0) {
    for (const a of artifacts) {
      sections.push(`- \`${a}\``);
    }
  } else {
    sections.push('No artifacts found.');
  }
  sections.push('');

  // Quality Issues
  sections.push('## Quality Issues');
  sections.push('');
  if (options.qualityIssues && options.qualityIssues.length > 0) {
    for (const qi of options.qualityIssues) {
      sections.push(`- ${qi}`);
    }
  } else {
    sections.push('No quality issues recorded.');
  }
  sections.push('');

  // Decisions
  sections.push('## Decisions');
  sections.push('');
  if (options.decisions && options.decisions.length > 0) {
    for (const d of options.decisions) {
      sections.push(`- ${d}`);
    }
  } else {
    const decisionLog = join(projectPaths.artifactsDir, 'context', 'decision-log.md');
    if (existsSync(decisionLog)) {
      sections.push('See `artifacts/context/decision-log.md` for full decision history.');
    } else {
      sections.push('No decisions recorded.');
    }
  }
  sections.push('');

  sections.push('---');
  sections.push('*Generated by bmad-swarm run reporter*');

  const content = sections.join('\n');
  writeFileSafe(reportPath, content);
  return reportPath;
}

/**
 * Collect artifact file paths relative to the artifacts directory.
 * @param {object} projectPaths
 * @returns {string[]}
 */
function collectArtifacts(projectPaths) {
  const artifacts = [];
  if (!existsSync(projectPaths.artifactsDir)) return artifacts;

  const subdirs = ['exploration', 'planning', 'design', 'design/decisions', 'implementation', 'implementation/stories', 'reviews', 'context'];
  for (const subdir of subdirs) {
    const dir = join(projectPaths.artifactsDir, subdir);
    if (!existsSync(dir)) continue;
    try {
      const files = readdirSync(dir).filter(f => !f.startsWith('.'));
      for (const file of files) {
        artifacts.push(`artifacts/${subdir}/${file}`);
      }
    } catch {
      // skip unreadable dirs
    }
  }
  return artifacts;
}

/**
 * Load phase info from project.yaml.
 * @param {object} projectPaths
 * @returns {object|null}
 */
function loadPhaseInfo(projectPaths) {
  return loadYaml(projectPaths.projectYaml);
}
