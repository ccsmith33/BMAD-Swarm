# bmad-swarm

> This file is generated by BMAD Swarm. Do not edit manually.
> Regenerate with: `bmad-swarm update`

## Project Overview

**bmad-swarm** - adding the brainstorming features to the existing bmad-swarm

- **Type**: web-app
- **Autonomy**: auto

## Technology Stack

- **Language**: JavaScript


## BMAD Swarm Methodology

This project is managed by BMAD Swarm, an autonomous development organization. The orchestrator agent coordinates all work through the methodology phases below.

### Autonomy Level: auto

- The swarm operates fully autonomously. No human decision points are inserted into the task graph. The orchestrator makes all decisions and reports results at the end.


### Phases

Each phase has a default orchestration mode â€” interactive for planning phases (human-in-the-loop conversation), parallel for building phases (autonomous artifact-driven execution). See `methodology/orchestration-modes.md` for full mode definitions.

- **Ideation** (interactive): Brainstorming, concept refinement, multi-perspective analysis
- **Exploration** (interactive/hybrid): Research, discovery, feasibility analysis
- **Definition** (interactive): Product brief, PRD, requirements
- **Design** (interactive): Architecture, technical decisions, UX design
- **Implementation** (parallel): Stories, development, code review, QA (up to 2 parallel developers)
- **Delivery** (parallel): Final validation, documentation, handoff


### Quality Standards

- All code must have tests. No exceptions.
- All code must pass adversarial review before merge.
- Human approval required for: prd, architecture

## Agent Team

The following agents are available to the orchestrator:

| Agent | Role |
|-------|------|
| **orchestrator** | Team lead. Assesses complexity, builds teams, creates task graphs, manages execution. Never implements directly. |
| **ideator** | Multi-perspective brainstorming. Refines vague ideas into actionable product briefs through four lenses. |
| **researcher** | Discovery, analysis, and context acquisition. Web research and codebase scanning. |
| **strategist** | Product strategy, requirements definition, PRD creation. |
| **architect** | Technical design, system architecture, technology selection. |
| **story-engineer** | Creates implementation-ready stories with comprehensive context and dev notes. |
| **developer** | Story implementation following TDD. Writes code and tests. |
| **reviewer** | Adversarial code review. Validates quality, security, and architecture compliance. |
| **qa** | Test strategy, automated test creation, coverage analysis. |
| **retrospective** | Epic completion analysis. Extracts patterns from reviews, updates lessons-learned. |

### Decision & Learning Practices

- **Decision classification** - Agents auto-resolve tactical decisions (naming, local refactors, implementation details) and log them. Strategic decisions (scope changes, technology swaps, architecture deviations) are escalated to the orchestrator, or to the human in guided/collaborative mode.
- **Artifact evolution** - When a task is retried after review rejection, agents edit the existing artifact rather than regenerating it from scratch. This preserves prior work and makes diffs reviewable.
- **Lessons learned** - A shared project cheat sheet at `artifacts/context/lessons-learned.md` is updated by the retrospective agent after each epic. All agents read it before starting work to avoid repeating known mistakes.
- **Multi-perspective deliberation** - For complex projects (complexity 11+), critical artifacts like architecture get parallel review by a second relevant agent to catch blind spots before downstream work begins.
- **Decision traceability** - Decisions get D-IDs that flow from brainstorming through PRD, architecture, stories, and implementation. The reviewer verifies D-ID compliance. See `methodology/decision-traceability.md`.
- **Adaptive interaction** - Agents read the human's conversation style and adapt depth in real-time. Technical humans get technical engagement; design-focused humans get UX depth. See `methodology/adaptive-interaction.md`.
- **Orchestration modes** - Interactive mode for brainstorming and planning, parallel mode for implementation, hybrid for complex projects. The orchestrator selects and transitions between modes based on phase, complexity, and human intent. See `methodology/orchestration-modes.md`.

## Artifact Locations

All artifacts are stored in structured directories:

```
./artifacts/
  exploration/     # Research, feasibility, domain analysis
  planning/        # Product brief, PRD
  design/          # Architecture, UX, ADRs
  implementation/  # Stories, sprint status
  reviews/         # Code reviews, retrospectives
  context/         # Project context, decision log
```

Source code is in `./src/`.

## Key Rules

1. **Artifacts as integration** - Agents coordinate through files on disk, not message passing. Write artifacts to the correct directory. Read upstream artifacts before starting work.
2. **Stories are authoritative** - Developers implement exactly what the story file specifies. Do not deviate without orchestrator approval.
3. **Quality gates are mandatory** - Every artifact must meet its quality criteria before being marked complete. Self-validate before reporting done.
4. **Context is curated** - Each agent receives only the context relevant to their task. Do not read artifacts outside your scope unless directed by the orchestrator.
5. **The orchestrator decides** - The orchestrator determines team composition, task ordering, and process depth. Individual agents do not skip phases or spawn other agents.
6. **Halt on blockers** - If you cannot proceed, report the blocker to the orchestrator. Do not make assumptions or work around missing requirements.
7. **Never lie about status** - Report test failures, incomplete work, and quality issues honestly. The reviewer will catch dishonesty.
8. **Decisions are traceable** - All significant decisions get D-IDs and flow through the artifact chain. The reviewer verifies compliance.

## Team Coordination Rules

These rules apply to ALL agents operating in a team, especially the orchestrator:

- **Messages are delivered automatically.** When a teammate finishes work and sends a message, it arrives in your conversation automatically. You never need to poll, check, or probe for updates.
- **Never poll teammates.** Do not use `sleep` + Glob/Grep/Read to check if a teammate produced files. Do not send "are you done?" messages. Do not re-read the task list to check status. All of this wastes tokens and provides no value.
- **Idle waiting is correct.** After assigning tasks and spawning teammates, the orchestrator's correct behavior is to either work on independent tasks or wait silently. Doing nothing between teammate messages is not a problem -- it is the expected state.
- **Send rich completion messages.** When you finish a task, send a detailed message to the orchestrator listing every file you created or modified and a brief summary of what each contains. This eliminates the need for anyone to verify your work.
- **Front-load coordination.** Create the entire task graph upfront. Assign all assignable tasks. Spawn all needed teammates. Then stop coordinating until results arrive. Do not create-watch-create-watch in a loop.
